From e500e0f6562249696d765c190deba8c41b3a91c7 Mon Sep 17 00:00:00 2001
From: Manish Dewangan <manish@codeaurora.org>
Date: Tue, 21 Jun 2011 13:36:35 +0530
Subject: [PATCH] msm: audio: qdsp5: Handle EOS buffer after audio flush

EOS buffer is not getting processed in following scenario is
encountered:
-Driver Recieves FLUSH command from apps
-Application sends EOS buffer to the driver after flush
command has completed
-NEEDS_DATA messages from DSP is Recieved by driver

In above scenario driver blocks for forever in write wait queue
and EOS buffer never gets processed.

Fix this by sending wakeup when NEEDS_DATA message is received.

CRs-Fixed: 292954, 293145
Signed-off-by: Manish Dewangan <manish@codeaurora.org>
(cherry picked from commit c729e63e1adc0b1e3b542477731e3485574150cd)

Change-Id: Iba4f7850e546d3816c31389a33984af28cca6503
Signed-off-by: Sunil Joseph <sunilj@codeaurora.org>
---
 arch/arm/mach-msm/qdsp5/audio_aac.c |   15 +++++++++++++++
 1 files changed, 15 insertions(+), 0 deletions(-)

diff --git a/arch/arm/mach-msm/qdsp5/audio_aac.c b/arch/arm/mach-msm/qdsp5/audio_aac.c
index 8a4d01f..bf2a2ad 100644
--- a/arch/arm/mach-msm/qdsp5/audio_aac.c
+++ b/arch/arm/mach-msm/qdsp5/audio_aac.c
@@ -132,6 +132,7 @@ struct audio {
 
 	int mfield; /* meta field embedded in data */
 	int rflush; /* Read  flush */
+	int eos_in_progress;
 	int wflush; /* Write flush */
 	int opened;
 	int enabled;
@@ -630,7 +631,12 @@ static void audplay_send_data(struct audio *audio, unsigned needed)
 			frame->used = 0;
 			audio->out_tail ^= 1;
 			wake_up(&audio->write_wait);
+		} else if ((audio->out[0].used == 0) &&
+			 (audio->out[1].used == 0) &&
+			 (audio->eos_in_progress)) {
+			wake_up(&audio->write_wait);
 		}
+
 	}
 
 	if (audio->out_needed) {
@@ -1290,6 +1296,7 @@ static int audaac_process_eos(struct audio *audio,
 	struct buffer *frame;
 	char *buf_ptr;
 	int rc = 0;
+	unsigned long flags = 0;
 
 	MM_DBG("signal input EOS reserved=%d\n", audio->reserved);
 	if (audio->reserved) {
@@ -1318,6 +1325,10 @@ static int audaac_process_eos(struct audio *audio,
 		audio->out[0].used, audio->out[1].used, audio->out_needed);
 	frame = audio->out + audio->out_head;
 
+	spin_lock_irqsave(&audio->dsp_lock, flags);
+	audio->eos_in_progress = 1;
+	spin_unlock_irqrestore(&audio->dsp_lock, flags);
+
 	rc = wait_event_interruptible(audio->write_wait,
 		(audio->out_needed &&
 		audio->out[0].used == 0 &&
@@ -1325,6 +1336,10 @@ static int audaac_process_eos(struct audio *audio,
 		|| (audio->stopped)
 		|| (audio->wflush));
 
+	spin_lock_irqsave(&audio->dsp_lock, flags);
+	audio->eos_in_progress = 0;
+	spin_unlock_irqrestore(&audio->dsp_lock, flags);
+
 	if (rc < 0)
 		goto done;
 	if (audio->stopped || audio->wflush) {
-- 
1.6.6.GIT

